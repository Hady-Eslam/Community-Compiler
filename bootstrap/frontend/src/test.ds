// Testing tokens!

/*
dec x = 8;
dec y = 21;

fn add(a: i32, b: i32) {
    return a + b;
}

dec z = add(x, y);

loop(z < 30) {
    z++;
}

4u16e
4u16
4i8
4i86

infix op -(a: i32, b: i32) { a-b } //pointless but get's the point across

infix fn minus(a: i32, b: i32) { a-b }

prefix fn dispose(...) {
    thing.dispose();
}

dispose [...];

::

@@

true
false

2
4.8
4f32
2.8e3f64

2f320
2.8e3f640

2
2.6
2u32
2.6f64
"te
st"
"t\""

2.6u32
u32
34.45e-4
45.67e+2
34.45e-4u32
45.67e+2f64

extern {
    fn thingy();
    fn other_thing();
}

extern fn do_maths(a: u32, b: u32);
*/

/*
var a: u32[];
let b: f64;

fn test() {}
fn test2(a: u32[], b: f64) {
    var thingamabobble: bool[];
    let pi: f32;
}

impl vec3 {
    @operator
    fn add(self: vec3, n: u32) {
        // Stuffs
    }

    infix op +(self: vec3, other: vec3): vec3 {
        // Stuffs
    }
}

prefix op *(addr: u64): any {
    // TODO
}

infix op <<-->>(a: u64, b: u64): u64 {
    // What even is this
}

1 shl 8

@precedence(6+1)
infix fn shl(n: u64, bits: u64): u64 {
    // Do things
}

some_function();
return;
return 6 + 14;
break;
continue;

struct vec3 {
    x: f32
    y: f32
    z: f32
}
var a: vec3;

function_thing(a + b - c + 10 - "haha");
*/

/*
fn repeat(self: str, amount: u32): str {
  var result = "";
  loop(amount) {
    result += self;
  }
  return result;
}

fn foo()
{

}
*/

/*
// We do not need to repeat a string 4 billion times
//why not?
// Life isn't about why, it's about why not?
// They spent so much time asking why not, they forgot to ask why
infix op *(string: str, amount: u32): str {
  return repeat(string, amount);
}
*/

//indexy[more_indexy[a-1]];
//a + indexy[0]

//let a = [0, 73, 42];
//var b = [];

/*if(a[0] == 0) {
    // ATHOIE
    do_things();
    b.push(a[1]);
} else if(a[1] == 1) {
    things();
} else {
    yay();
}
*/



loop (5) {
    // Do this 5 times
}

loop (true == true) {
    // While loop
}

loop (item in list) {
    // Foreach loop
}
